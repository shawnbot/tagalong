{"version":3,"sources":["webpack:///tagalong.js","webpack:///webpack/bootstrap a70bb060678c2b3ab6d4","webpack:///./src/main.js","webpack:///./src/t-template.js","webpack:///./src/property.js","webpack:///./src/evaluate.js","webpack:///./src/arrow.js","webpack:///./src/functor.js","webpack:///./src/render.js","webpack:///./src/interpolate.js","webpack:///./src/compose.js","webpack:///./src/util.js","webpack:///./src/h.js","webpack:///./src/ns.js","webpack:///./src/constants.js","webpack:///./src/attrs.js","webpack:///./src/dom.js","webpack:///./src/scope.js"],"names":["modules","__webpack_require__","moduleId","installedModules","exports","module","id","loaded","call","m","c","p","e","Error","code","Template","render","window","tagalong","createRenderer","create","property","evaluate","RENDER","DATA_ATTR","document","registerElement","prototype","Object","HTMLElement","attachedCallback","value","this","update","attributeChangedCallback","attr","previous","console","log","hasAttribute","expr","getAttribute","data","arguments","length","renderTo","node","invalidate","defineProperty","get","read","write","defaultValue","symbol","Date","now","enumerable","set","undefined","identity","d","arrow","functor","expression","fn","evaluator","String","trim","is","parse","match","Function","join","ARROW_PATTERN","isArrow","parseArrow","args","body","x","interpolate","compose","h","morphdom","T","T_ID","dom","util","ns","scope","EVENTS","eventHandlerId","eventHandlersById","createTextRenderer","stringify","compile","nodeValue","pluckEventHandlers","attrMap","handlers","name","indexOf","substr","registerEventHandlers","index","apply","tid","setAttribute","context","callback","event","type","bound","createElementRenderer","SKIP","getPrefixedName","getAttributeMap","condition","IF","ELSE","ifSibling","getPreviousSibling","not","renderChildren","TEXT","compileExpression","childRenderers","map","childNodes","renderChild","i","renderNode","attrs","interpolateAttributes","children","eachExpression","EACH","forEachExpression","FOREACH","withExpression","WITH","AS","renderEach","renderWith","symbolSetter","src","selector","querySelector","options","dest","result","updateEventHandlers","root","elements","slice","querySelectorAll","unshift","forEach","el","events","removeEventListener","addEventListener","removeAttribute","renderData","nodeType","pattern","isTemplate","str","RegExp","test","template","that","replace","_","part","defined","props","Array","isArray","createDocumentFragment","qualify","namespaceURI","createElementNS","localName","createElement","setProps","append","child","appendChild","createTextNode","prop","hasOwnProperty","formatClassName","formatStyle","warn","setAttributeNS","obj","keys","key","reformatCamelCase","char","toLowerCase","filter","prefixToURI","svg","xlink","xmlns","uriToPrefix","prefix","qname","colon","nodeName","PREFIX","CONTROL_ATTRS","constants","T_PREFIX","attributes","previousSibling","matches","values","iterate","INDEX","each","push","split"],"mappings":"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","file":"tagalong.js","sourcesContent":["/******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId])\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\texports: {},\n/******/ \t\t\tid: moduleId,\n/******/ \t\t\tloaded: false\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.loaded = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(0);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t__webpack_require__(!(function webpackMissingModule() { var e = new Error(\"Cannot find module \\\"document-register-element\\\"\"); e.code = 'MODULE_NOT_FOUND'; throw e; }()));\n\t\n\tvar Template = __webpack_require__(1);\n\tvar render = __webpack_require__(6);\n\t\n\twindow.tagalong = {\n\t  Template: Template,\n\t  createRenderer: render.create,\n\t  render: render.render\n\t};\n\n\n/***/ },\n/* 1 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar property = __webpack_require__(2);\n\tvar evaluate = __webpack_require__(3).evaluate;\n\tvar createRenderer = __webpack_require__(6).create;\n\t\n\tvar RENDER = '[[t-render]]';\n\t\n\tvar DATA_ATTR = 'data';\n\t\n\tvar Template = document.registerElement('t-template', {\n\t  prototype: Object.create(\n\t    HTMLElement.prototype,\n\t    {\n\t      attachedCallback: {value: function() {\n\t        this.update();\n\t      }},\n\t\n\t      // eslint-disable-next-line no-unused-vars\n\t      attributeChangedCallback: {value: function(attr, value, previous) {\n\t        switch (attr) {\n\t          case DATA_ATTR:\n\t            this.update();\n\t            break;\n\t          default:\n\t            return;\n\t        }\n\t      }},\n\t\n\t      update: {value: function() {\n\t        console.log('updating...');\n\t        if (this.hasAttribute(DATA_ATTR)) {\n\t          var expr = this.getAttribute(DATA_ATTR);\n\t          var data = evaluate(expr);\n\t          console.log('setting data: (', expr, ') ->', data);\n\t          this.data = data;\n\t        }\n\t      }},\n\t\n\t      /**\n\t       * @param {Object?} data\n\t       */\n\t      render: {value: function(data) {\n\t        if (!arguments.length) {\n\t          data = this.data;\n\t        }\n\t\n\t        var render = this[RENDER];\n\t        if (!render) {\n\t          render = this[RENDER] = createRenderer(this);\n\t        }\n\t\n\t        render(data);\n\t        return data;\n\t      }},\n\t\n\t      /**\n\t       * @param {Element} node\n\t       * @param {Object?} data\n\t       */\n\t      renderTo: {value: function(node, data) {\n\t        if (arguments.length < 2) {\n\t          data = this.data;\n\t        }\n\t\n\t        var render = this[RENDER];\n\t        if (!render) {\n\t          render = this[RENDER] = createRenderer(this);\n\t        }\n\t        render(node, data);\n\t        return data;\n\t      }},\n\t\n\t      /**\n\t       * Invalidate this element's compiled template, so that it\n\t       * will be recompiled on the next render.\n\t       */\n\t      invalidate: {value: function() {\n\t        this[RENDER] = null;\n\t      }},\n\t\n\t      /**\n\t       * Returns the element's bound data.\n\t       */\n\t      data: property(\n\t        function readTemplateData(data) {\n\t          return data;\n\t        },\n\t        // eslint-disable-next-line no-unused-vars\n\t        function setTemplateData(data, previous) {\n\t          return this.render(data);\n\t        },\n\t        {}\n\t      )\n\t    }\n\t  )\n\t});\n\t\n\t// only listen for changes to the data attribute\n\tObject.defineProperty(Template, 'observedAttributes', {\n\t  get: function() {\n\t    return [DATA_ATTR];\n\t  }\n\t});\n\t\n\tmodule.exports = Template;\n\n\n/***/ },\n/* 2 */\n/***/ function(module, exports) {\n\n\tmodule.exports = function property(read, write, defaultValue) {\n\t  var symbol = '[[t-' + Date.now() + ']]';\n\t  return {\n\t    enumerable: false,\n\t\n\t    get: function() {\n\t      var value = (symbol in this)\n\t        ? this[symbol]\n\t        : this[symbol] = defaultValue;\n\t      return read\n\t        ? read.call(this, value)\n\t        : value;\n\t    },\n\t\n\t    set: function(value) {\n\t      var previous = this[symbol];\n\t      if (value !== previous) {\n\t        // eslint-disable-next-line no-return-assign\n\t        return this[symbol] = write.call(this, value, previous);\n\t      }\n\t      return undefined;\n\t    }\n\t  };\n\t};\n\n\n/***/ },\n/* 3 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/* eslint no-new-func: \"warn\" */\n\tvar arrow = __webpack_require__(4);\n\tvar functor = __webpack_require__(5);\n\t\n\tvar evaluate = function(expression, data) {\n\t  var fn = evaluator(expression);\n\t  return fn.call(this, data);\n\t};\n\t\n\tvar evaluator = function(expression) {\n\t  if (typeof expression !== 'string') {\n\t    expression = String(expression);\n\t  }\n\t\n\t  if (!expression.trim()) {\n\t    return functor(undefined);\n\t  }\n\t\n\t  if (arrow.is(expression)) {\n\t    return arrow.parse(expression);\n\t  }\n\t\n\t  var symbol = 'd';\n\t  // '.' is just the identity function\n\t  if (expression.match(/^\\s*\\.\\s*$/)) {\n\t    return identity;\n\t  // '.foo' addresses the context directly\n\t  } else if (expression.match(/^\\s*\\.\\w/)) {\n\t    expression = symbol + expression;\n\t  }\n\t  return new Function(symbol, [\n\t    // 'console.info(\"', symbol, ' = \", ', symbol, ', \"', expression, '\"); ',\n\t    'try { ',\n\t    '  with (this) {',\n\t    '    with (', symbol, ') {',\n\t    '      return (', expression, ');',\n\t    '    } ',\n\t    '  } ',\n\t    '} catch (error) { }'\n\t  ].join('\\n'));\n\t};\n\t\n\tmodule.exports = {\n\t  evaluate: evaluate,\n\t  evaluator: evaluator\n\t};\n\t\n\tfunction identity(d) {\n\t  return d;\n\t}\n\n\n/***/ },\n/* 4 */\n/***/ function(module, exports) {\n\n\t/* eslint no-new-func: \"warn\" */\n\tvar ARROW_PATTERN = /^\\s*\\(?(\\s*\\w+\\s*(,\\s*\\w+\\s*)*)?\\)?\\s*=>\\s*({([^}]+)}|(.+))$/;\n\t\n\tvar isArrow = function(expression) {\n\t  return String(expression).match(ARROW_PATTERN);\n\t};\n\t\n\tvar parseArrow = function parseArrow(expression) {\n\t  var match = expression.match(ARROW_PATTERN);\n\t  if (!match) throw new Error('invalid arrow expression: \"' + expression + '\"');\n\t  var args = match[1];\n\t  var body = (match[4] || match[5]).trim() || 'undefined';\n\t  return new Function(args, [\n\t    'with (this) {',\n\t    ' return ', body, '; ',\n\t    '}',\n\t  ].join(''));\n\t};\n\t\n\tmodule.exports = {\n\t  is: isArrow,\n\t  parse: parseArrow\n\t};\n\n\n/***/ },\n/* 5 */\n/***/ function(module, exports) {\n\n\tmodule.exports = function functor(x) {\n\t  return function f() {\n\t    return x;\n\t  };\n\t};\n\t\n\n\n/***/ },\n/* 6 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar code = __webpack_require__(3);\n\tvar interpolate = __webpack_require__(7);\n\tvar compose = __webpack_require__(8);\n\tvar h = __webpack_require__(10);\n\t\n\tvar morphdom = __webpack_require__(!(function webpackMissingModule() { var e = new Error(\"Cannot find module \\\"morphdom\\\"\"); e.code = 'MODULE_NOT_FOUND'; throw e; }()));\n\t\n\tvar T = __webpack_require__(12).T;\n\tvar T_ID = 't-id';\n\tvar attr = __webpack_require__(13);\n\tvar dom = __webpack_require__(14);\n\tvar util = __webpack_require__(9);\n\tvar ns = __webpack_require__(11);\n\tvar scope = __webpack_require__(15);\n\t\n\t// this is our symbol on which we stash registered event handlers, so that\n\t// we can remove any registered handlers before adding new ones.\n\tvar EVENTS = '[[t-events]]';\n\t\n\t// we stash unique event handler ids and handlers by id, each bound to the\n\t// renered template data\n\tvar eventHandlerId = 0;\n\tvar eventHandlersById = {};\n\t\n\t/**\n\t * Returns a function that generates an interpolated string for the\n\t * given text node (`node.nodeType === Node.TEXT_NODE`).\n\t *\n\t * @param {Node} node\n\t * @return {Function} function(data:Object):String\n\t */\n\tvar createTextRenderer = function(node) {\n\t  return compose.stringify(interpolate.compile(node.nodeValue));\n\t};\n\t\n\t/**\n\t * \"Pluck\" event handlers from an attribute map, removing them from\n\t * the map. If no event handlers are found, the return value is\n\t * `undefined`.\n\t *\n\t * @param {Object} attrMap\n\t * @return {Object}\n\t */\n\tvar pluckEventHandlers = function(attrMap) {\n\t  var handlers = undefined;\n\t  for (var name in attrMap) {\n\t    var value = attrMap[name];\n\t    if (name.indexOf('on') === 0 && typeof value === 'function') {\n\t      if (!handlers) {\n\t        handlers = {};\n\t      }\n\t      handlers[name.substr(2)] = value;\n\t      delete attrMap[name];\n\t    }\n\t  }\n\t  return handlers;\n\t};\n\t\n\t/**\n\t * This function returns a node rendering wrapper that registers event handlers\n\t * for the rendered node by assigning it a unique `t-id` attribute and stashing\n\t * a reference to the data-bound handlers in a corresponding hash. After the\n\t * tree is morphed, each element with a `t-id` attribute is then matched up\n\t * with its event handlers.\n\t *\n\t * @param {Function} render\n\t * @param {Object} handlers each key is an event type, and the value is a\n\t * callback function.\n\t * @return {Function} a function that returns the rendered node\n\t */\n\tvar registerEventHandlers = function(render, handlers) {\n\t  return function(data, index) {\n\t    var node = render.apply(this, arguments);\n\t    if (node) {\n\t      var tid = ++eventHandlerId;\n\t      node.setAttribute(T_ID, tid);\n\t      var context = this;\n\t      var callback = function(event) {\n\t        // XXX in theory, this could fail if one\n\t        // of the handlers gets removed (not\n\t        // sure how that would happen, though)\n\t        handlers[event.type].call(context, data, event);\n\t      };\n\t      var bound = {};\n\t      for (var type in handlers) {\n\t        bound[type] = callback;\n\t      }\n\t      eventHandlersById[tid] = bound;\n\t    }\n\t    return node;\n\t  };\n\t};\n\t\n\t/**\n\t * Returns a function that generates an interpolated DOM element tree\n\t * for the given element node\n\t * (`node.nodeType === Node.ELEMENT_NODE`).\n\t *\n\t * @param {Element} node\n\t * @return {Function} function(data:Object):Element\n\t */\n\tvar createElementRenderer = function(node) {\n\t  // this element will never be rendered if it has a truthy t-skip\n\t  // attribute\n\t  if (node.hasAttribute(T.SKIP)) {\n\t    return undefined;\n\t  }\n\t\n\t  var name = ns.getPrefixedName(node);\n\t  var attrMap = attr.getAttributeMap(node);\n\t  var handlers = pluckEventHandlers(attrMap);\n\t\n\t  var condition = node.hasAttribute(T.IF)\n\t    ? code.evaluator(node.getAttribute(T.IF))\n\t    : undefined;\n\t\n\t  if (node.hasAttribute(T.ELSE)) {\n\t    if (condition) {\n\t      throw new Error('element has both t-if and t-else attributes');\n\t    }\n\t    // TODO: ELSEIF should just collect all of the previous IF and\n\t    // ELSEIF nodes and negate them. Some checking should happen here to\n\t    // ensure that they're specified in the correct order.\n\t    var ifSibling = dom.getPreviousSibling(node, '[' + T.IF + ']');\n\t    if (!ifSibling) {\n\t      throw new Error('element with t-else has no matching t-if sibling');\n\t    }\n\t    condition = compose.not(code.evaluator(ifSibling.getAttribute(T.IF)));\n\t  }\n\t\n\t  var renderChildren;\n\t\n\t  // <span t-text=\"some.value\"></span>\n\t  if (node.hasAttribute(T.TEXT)) {\n\t    renderChildren = compose.stringify(\n\t      util.compileExpression(node.getAttribute(T.TEXT))\n\t    );\n\t  } else {\n\t    var childRenderers = [].map.call(node.childNodes, compile);\n\t    renderChildren = function(data) {\n\t      return childRenderers.map(function(renderChild, i) {\n\t        return (typeof renderChild === 'function')\n\t          ? renderChild.call(this, data)\n\t          : renderChild;\n\t      }, this);\n\t    };\n\t  }\n\t\n\t  var renderNode = function(data) {\n\t    if (condition && !condition.call(this, data)) {\n\t      return undefined;\n\t    }\n\t\n\t    var attrs = attr.interpolateAttributes.call(this, attrMap, data);\n\t    var children = renderChildren.call(this, data);\n\t    return h(name, attrs, children);\n\t  };\n\t\n\t  // \"attach\" (as a single property) the event handler maps\n\t  if (handlers) {\n\t    renderNode = registerEventHandlers(renderNode, handlers);\n\t  }\n\t\n\t  var eachExpression = node.getAttribute(T.EACH);\n\t  var forEachExpression = node.getAttribute(T.FOREACH);\n\t  var withExpression = node.getAttribute(T.WITH);\n\t\n\t  var symbol = node.getAttribute(T.AS);\n\t\n\t  if (eachExpression) {\n\t    renderNode = scope.renderEach(\n\t      code.evaluator(eachExpression),\n\t      renderNode,\n\t      symbol\n\t    );\n\t  } else if (forEachExpression) {\n\t    renderChildren = scope.renderEach(\n\t      code.evaluator(forEachExpression),\n\t      renderChildren,\n\t      symbol\n\t    );\n\t  } else if (withExpression) {\n\t    renderNode = scope.renderWith(\n\t      code.evaluator(withExpression),\n\t      renderNode,\n\t      symbol\n\t    );\n\t  } else if (symbol) {\n\t    renderNode = scope.symbolSetter(symbol, renderNode);\n\t  }\n\t\n\t  return renderNode;\n\t};\n\t\n\t/**\n\t * Returns a rendering function for a given source (\"template\") node\n\t * and optional variable context for expressions.\n\t *\n\t * The returned function has the signatures:\n\t *\n\t * function(data:*)\n\t * function(node:Node, data:*)\n\t *\n\t * Where `data` is expected to be an object and, in the second form,\n\t * `node` is a target node to which the diffed DOM should be applied.\n\t *\n\t * @param {Node}    src\n\t * @param {Object?} context\n\t * @return {Function}\n\t */\n\tvar createRenderer = function(src, context) {\n\t  if (typeof src === 'string') {\n\t    var selector = src;\n\t    src = document.querySelector(src);\n\t    if (!src) {\n\t      throw new Error('no element found with selector: \"' + selector + '\"');\n\t    }\n\t  }\n\t\n\t  var renderNode = compile(src);\n\t  return function(node, data, options) {\n\t    if (arguments.length < 2) {\n\t      data = node;\n\t    }\n\t    if ((!node && data) || node === data) {\n\t      node = src;\n\t    }\n\t    eventHandlerId = 0;\n\t    eventHandlersById = {};\n\t    var dest = renderNode.call(context, data);\n\t    var result = morphdom(src, dest, options);\n\t    updateEventHandlers(result);\n\t    return result;\n\t  };\n\t};\n\t\n\t/**\n\t * Update all of the event handlers in the given DOM tree. This looks for all\n\t * elements with the `t-id` attribute (including the root), removes any\n\t * existing handlers (stashed in the `[[t-events]]` symbol), then looks up the\n\t * registered handlers for the corresponding `t-id` value and adds those.\n\t *\n\t * @param {Element} root\n\t */\n\tvar updateEventHandlers = function(root) {\n\t  var elements = [].slice.call(root.querySelectorAll('[' + T_ID + ']'));\n\t  if (root.hasAttribute(T_ID)) {\n\t    elements.unshift(root);\n\t  }\n\t  elements.forEach(function(el) {\n\t    var events = el[EVENTS];\n\t    var type;\n\t    if (events) {\n\t      for (type in events) {\n\t        el.removeEventListener(type, events[type], true);\n\t        delete events[type];\n\t      }\n\t      delete el[EVENTS];\n\t    }\n\t    var tid = el.getAttribute(T_ID);\n\t    events = eventHandlersById[tid];\n\t    if (events) {\n\t      for (type in events) {\n\t        el.addEventListener(type, events[type], true);\n\t      }\n\t      el[EVENTS] = events;\n\t    }\n\t    el.removeAttribute(T_ID);\n\t  });\n\t};\n\t\n\t/**\n\t * Creates a renderer, renders once if data is provided, and returns\n\t * a bound rendering function for subsequent calling.\n\t *\n\t * @param {Node}    src\n\t * @param {Object?} context\n\t * @return {Function}\n\t */\n\tvar render = function(src, data, context) {\n\t  var renderData = createRenderer(src, context);\n\t  if (data) {\n\t    renderData(src, data);\n\t  }\n\t  return renderData;\n\t};\n\t\n\t/**\n\t * Returns a DOM element rendering function for the given \"template\"\n\t * or source node. This may be publicly exposed if it becomes useful,\n\t * e.g. for composition of referenced templates.\n\t *\n\t * @param {Node} node\n\t * @return {Function} the returned function takes data and returns an\n\t * unattached Node instance: function(data:Object):Node\n\t */\n\tvar compile = function(node) {\n\t  switch (node.nodeType) {\n\t    case 1: // Node.ELEMENT_NODE\n\t      return createElementRenderer(node);\n\t    case 3: // Node.TEXT_NODE\n\t      return createTextRenderer(node);\n\t\n\t    // TODO: support document fragments?\n\t    // this would need support in h()\n\t\n\t    default:\n\t      throw new Error('no renderer for node type: ' + node.nodeType);\n\t  }\n\t};\n\t\n\t\n\tmodule.exports.render = render;\n\tmodule.exports.createRenderer = createRenderer;\n\tmodule.exports.compile = compile;\n\n\n/***/ },\n/* 7 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar evaluate = __webpack_require__(3).evaluate;\n\tvar functor = __webpack_require__(5);\n\t\n\tvar pattern = /{{\\s*([^}]+)\\s*}}/g;\n\t\n\tvar isTemplate = function(str) {\n\t  return new RegExp(pattern).test(str);\n\t};\n\t\n\tvar compile = function(template) {\n\t  if (typeof template !== 'string') {\n\t    throw new Error('interpolate.compile() expected a string;' +\n\t                    'got ' + (typeof template));\n\t  }\n\t\n\t  if (!isTemplate(template)) {\n\t    return functor(template);\n\t  }\n\t\n\t  return function(data) {\n\t    var that = this;\n\t    return template.replace(pattern, function(_, part) {\n\t      return evaluate.call(that, part, data);\n\t    });\n\t  };\n\t};\n\t\n\tvar interpolate = function interpolate(str, data) {\n\t  return compile(str).call(this, data);\n\t};\n\t\n\tmodule.exports = interpolate;\n\t\n\tmodule.exports.isTemplate = isTemplate;\n\t\n\tmodule.exports.compile = compile;\n\n\n/***/ },\n/* 8 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/**\n\t * functional composition functions take a function and return a\n\t * wrapped function that calls the passed one and applies some\n\t * additional logic.\n\t */\n\t\n\tvar defined = __webpack_require__(9).defined;\n\t\n\t/**\n\t * @param {Function}  fn\n\t * @return {Function} a function that returns the inverse (`!`)\n\t *                    value of the `fn`, given the same arguments.\n\t */\n\tmodule.exports.not = function(fn) {\n\t  return function() {\n\t    return !fn.apply(this, arguments);\n\t  };\n\t};\n\t\n\t/**\n\t * @param {Function}  fn\n\t * @return {Function} a function that returns the stringified\n\t *                    value of the `fn`, given the same arguments.\n\t */\n\tmodule.exports.stringify = function(fn) {\n\t  return function() {\n\t    var value = fn.apply(this, arguments);\n\t    return defined(value) ? String(value) : '';\n\t  };\n\t};\n\n\n/***/ },\n/* 9 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar code = __webpack_require__(3);\n\tvar interpolate = __webpack_require__(7);\n\t\n\tmodule.exports.defined = function(value) {\n\t  return value !== null && value !== undefined;\n\t};\n\t\n\tmodule.exports.compileExpression = function(expr) {\n\t  return interpolate.isTemplate(expr)\n\t    ? interpolate.compile(expr)\n\t    : code.evaluator(expr);\n\t};\n\n\n/***/ },\n/* 10 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar ns = __webpack_require__(11);\n\t\n\tmodule.exports = function(name, props, children) {\n\t  var node;\n\t  if (Array.isArray(name)) {\n\t    node = document.createDocumentFragment();\n\t  } else {\n\t    name = ns.qualify(name);\n\t    node = name.namespaceURI\n\t      ? document.createElementNS(name.namespaceURI, name.localName)\n\t      : document.createElement(name.localName);\n\t  }\n\t\n\t  if (Array.isArray(props) || typeof props === 'string') {\n\t    children = props;\n\t  } else if (typeof props === 'object') {\n\t    setProps(node, props);\n\t  }\n\t\n\t  var append = function(child) {\n\t    if (Array.isArray(child)) {\n\t      child.forEach(append);\n\t    } else if (typeof child === 'object') {\n\t      node.appendChild(child);\n\t    } else if (typeof child === 'string') {\n\t      node.appendChild(document.createTextNode(child));\n\t    }\n\t  };\n\t\n\t  if (typeof children === 'object' || typeof children === 'string') {\n\t    append(children);\n\t  }\n\t\n\t  return node;\n\t};\n\t\n\tvar setProps = function(el, props) {\n\t  for (var prop in props) {\n\t    if (!props.hasOwnProperty(prop)) {\n\t      continue;\n\t    }\n\t    var value = props[prop];\n\t    if (value === null || value === undefined || typeof value === 'function') {\n\t      // XXX: don't add null, undefined, or function values\n\t      continue;\n\t    } else if (typeof value === 'object') {\n\t      switch (prop) {\n\t        case 'class':\n\t          value = formatClassName(value);\n\t          break;\n\t\n\t        case 'style':\n\t          value = formatStyle(value);\n\t          break;\n\t\n\t        default:\n\t          console.warn('unrecognized object prop:', prop, value);\n\t          continue;\n\t      }\n\t    }\n\t\n\t    var name = ns.qualify(prop);\n\t    if (name.namespaceURI) {\n\t      el.setAttributeNS(name.namespaceURI, name.name, value);\n\t    } else {\n\t      el.setAttribute(name.localName, value);\n\t    }\n\t  }\n\t};\n\t\n\tvar formatStyle = function(obj) {\n\t  if (Array.isArray(obj)) {\n\t    return obj.join('; ');\n\t  }\n\t  return Object.keys(obj)\n\t    .map(function(key) {\n\t      return [\n\t        reformatCamelCase(key),\n\t        ': ',\n\t        obj[key],\n\t        ';'\n\t      ].join('');\n\t    })\n\t    .join(' ');\n\t};\n\t\n\tvar reformatCamelCase = function(str) {\n\t  return str.replace(/[A-Z]/g, function(char) {\n\t    return '-' + char.toLowerCase();\n\t  });\n\t};\n\t\n\tvar formatClassName = function(obj) {\n\t  if (Array.isArray(obj)) {\n\t    return obj.join(' ');\n\t  }\n\t  return Object.keys(obj).filter(function(key) {\n\t    return !!obj[key];\n\t  }).join(' ');\n\t};\n\n\n/***/ },\n/* 11 */\n/***/ function(module, exports) {\n\n\tvar prefixToURI = {\n\t  svg: 'http://www.w3.org/2000/svg',\n\t  xlink: 'http://www.w3.org/TR/xlink/',\n\t  xmlns: 'http://www.w3.org/2000/xmlns/'\n\t};\n\t\n\tvar uriToPrefix = {};\n\tObject.keys(prefixToURI).forEach(function(prefix) {\n\t  uriToPrefix[prefixToURI[prefix]] = prefix;\n\t});\n\t\n\tvar qualify = function(qname) {\n\t  var prefix;\n\t  var localName = qname;\n\t  var colon = qname.indexOf(':');\n\t  if (colon > -1) {\n\t    prefix = qname.substr(0, colon);\n\t    localName = qname.substr(colon + 1);\n\t  }\n\t  return {\n\t    name: qname,\n\t    localName: localName,\n\t    prefix: prefix,\n\t    namespaceURI: prefixToURI[prefix]\n\t  };\n\t};\n\t\n\tvar getPrefixedName = function(node) {\n\t  var name = node.nodeName.toLowerCase();\n\t  var prefix = node.prefix;\n\t  if (!prefix && node.namespaceURI) {\n\t    prefix = uriToPrefix[node.namespaceURI];\n\t  }\n\t  return prefix\n\t    ? (prefix + ':' + name)\n\t    : name;\n\t};\n\t\n\tmodule.exports = {\n\t  getPrefixedName: getPrefixedName,\n\t  prefixToURI: prefixToURI,\n\t  uriToPrefix: uriToPrefix,\n\t  qualify: qualify\n\t};\n\n\n/***/ },\n/* 12 */\n/***/ function(module, exports) {\n\n\tvar prefix = 't-';\n\t\n\tvar T = {\n\t  PREFIX: prefix\n\t};\n\t\n\tT.AS = prefix + 'as';\n\tT.EACH = prefix + 'each';\n\tT.ELSE = prefix + 'else';\n\tT.FOREACH = prefix + 'foreach';\n\tT.IF = prefix + 'if';\n\tT.SKIP = prefix + 'skip';\n\tT.TEXT = prefix + 'text';\n\tT.WITH = prefix + 'with';\n\t\n\tmodule.exports.T = T;\n\t\n\tmodule.exports.CONTROL_ATTRS = [\n\t  'as',\n\t  'each',\n\t  'else',\n\t  'foreach',\n\t  'if',\n\t  'skip',\n\t  'text',\n\t  'with'\n\t];\n\n\n/***/ },\n/* 13 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar constants = __webpack_require__(12);\n\tvar T_PREFIX = constants.T.PREFIX;\n\tvar CONTROL_ATTRS = constants.CONTROL_ATTRS;\n\t\n\tvar ns = __webpack_require__(11);\n\tvar util = __webpack_require__(9);\n\tvar defined = util.defined;\n\t\n\tmodule.exports.getAttributeMap = function(node) {\n\t  var map = {};\n\t  var attrs = node.attributes;\n\t  for (var i = 0; i < attrs.length; i++) {\n\t    var attr = attrs[i];\n\t    var name = ns.qualify(attr.name);\n\t    var localName = name.localName;\n\t    var value = attr.value;\n\t    if (localName.indexOf(T_PREFIX) === 0) {\n\t      localName = localName.substr(T_PREFIX.length);\n\t      if (CONTROL_ATTRS.indexOf(localName) > -1) {\n\t        continue;\n\t      }\n\t      value = util.compileExpression(value);\n\t    }\n\t    var qname = name.prefix\n\t      ? name.prefix + ':' + localName\n\t      : localName;\n\t    map[qname] = value;\n\t  }\n\t  return map;\n\t};\n\t\n\tmodule.exports.interpolateAttributes = function(attrMap, data) {\n\t  var attrs = {};\n\t  for (var key in attrMap) {\n\t    if (!attrMap.hasOwnProperty(key)) {\n\t      continue;\n\t    }\n\t    var value = attrMap[key];\n\t    // only apply functions for attrs that aren't event handlers\n\t    if (typeof value === 'function' && key.indexOf('on') !== 0) {\n\t      value = value.call(this, data, key);\n\t    }\n\t    if (defined(value)) {\n\t      attrs[key] = value;\n\t    }\n\t  }\n\t  return attrs;\n\t};\n\n\n/***/ },\n/* 14 */\n/***/ function(module, exports) {\n\n\tmodule.exports.getPreviousSibling = function(node, selector) {\n\t  // eslint-disable-next-line no-cond-assign\n\t  while (node = node.previousSibling) {\n\t    if (!node) break;\n\t    // FIXME this needs a vendor prefix in IE 9+\n\t    // <http://caniuse.com/#search=matches>\n\t    if (node.nodeType === 1 && node.matches(selector)) {\n\t      return node;\n\t    }\n\t  }\n\t  throw new Error('no previous sibling found matching: ' + selector);\n\t};\n\n\n/***/ },\n/* 15 */\n/***/ function(module, exports) {\n\n\tvar renderEach = function(fn, render, symbol) {\n\t  return function(data) {\n\t    var values = fn.call(this, data);\n\t    return forEach.call(this, values, render, symbol);\n\t  };\n\t};\n\t\n\tvar renderWith = function(fn, render, symbol) {\n\t  render = symbolSetter(symbol, render);\n\t  return function(data) {\n\t    data = fn.call(this, data);\n\t    return render.call(this, data);\n\t  };\n\t};\n\t\n\tvar forEach = function(data, fn, symbol) {\n\t  var iterate = symbol\n\t    ? symbolSetter(symbol, fn)\n\t    : fn;\n\t\n\t  var result = [];\n\t  var INDEX = '$i';\n\t  var each = function(d, i) {\n\t    this[INDEX] = i;\n\t    result.push(iterate.call(this, d));\n\t    delete this[INDEX];\n\t  };\n\t\n\t  if (typeof data === 'object') {\n\t    if (Array.isArray(data)) {\n\t      data.forEach(each, this);\n\t    } else {\n\t      var i = 0;\n\t      for (var key in data) {\n\t        if (data.hasOwnProperty(key)) {\n\t          each.call(this, {key: key, value: data[key]}, i++);\n\t        }\n\t      }\n\t    }\n\t  } else if (typeof data === 'string') {\n\t    data.split('').forEach(each, this);\n\t  }\n\t\n\t  return result;\n\t};\n\t\n\tvar symbolSetter = function(symbol, fn) {\n\t  return function(data) {\n\t    var previous = set(this, symbol, data);\n\t    var result = fn.call(this, data);\n\t    set(this, symbol, previous);\n\t    return result;\n\t  };\n\t};\n\t\n\tvar set = function(context, symbol, value) {\n\t  var previous = context[symbol];\n\t  if (value === undefined) {\n\t    delete context[symbol];\n\t  } else {\n\t    context[symbol] = value;\n\t  }\n\t  return previous;\n\t};\n\t\n\tmodule.exports = {\n\t  renderWith: renderWith,\n\t  renderEach: renderEach,\n\t  symbolSetter: symbolSetter\n\t};\n\n\n/***/ }\n/******/ ]);\n\n\n/** WEBPACK FOOTER **\n ** tagalong.js\n **/"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId])\n \t\t\treturn installedModules[moduleId].exports;\n\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\texports: {},\n \t\t\tid: moduleId,\n \t\t\tloaded: false\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.loaded = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(0);\n\n\n\n/** WEBPACK FOOTER **\n ** webpack/bootstrap a70bb060678c2b3ab6d4\n **/","require('document-register-element');\n\nvar Template = require('./t-template');\nvar render = require('./render');\n\nwindow.tagalong = {\n  Template: Template,\n  createRenderer: render.create,\n  render: render.render\n};\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./src/main.js\n ** module id = 0\n ** module chunks = 0\n **/","var property = require('./property');\nvar evaluate = require('./evaluate').evaluate;\nvar createRenderer = require('./render').create;\n\nvar RENDER = '[[t-render]]';\n\nvar DATA_ATTR = 'data';\n\nvar Template = document.registerElement('t-template', {\n  prototype: Object.create(\n    HTMLElement.prototype,\n    {\n      attachedCallback: {value: function() {\n        this.update();\n      }},\n\n      // eslint-disable-next-line no-unused-vars\n      attributeChangedCallback: {value: function(attr, value, previous) {\n        switch (attr) {\n          case DATA_ATTR:\n            this.update();\n            break;\n          default:\n            return;\n        }\n      }},\n\n      update: {value: function() {\n        console.log('updating...');\n        if (this.hasAttribute(DATA_ATTR)) {\n          var expr = this.getAttribute(DATA_ATTR);\n          var data = evaluate(expr);\n          console.log('setting data: (', expr, ') ->', data);\n          this.data = data;\n        }\n      }},\n\n      /**\n       * @param {Object?} data\n       */\n      render: {value: function(data) {\n        if (!arguments.length) {\n          data = this.data;\n        }\n\n        var render = this[RENDER];\n        if (!render) {\n          render = this[RENDER] = createRenderer(this);\n        }\n\n        render(data);\n        return data;\n      }},\n\n      /**\n       * @param {Element} node\n       * @param {Object?} data\n       */\n      renderTo: {value: function(node, data) {\n        if (arguments.length < 2) {\n          data = this.data;\n        }\n\n        var render = this[RENDER];\n        if (!render) {\n          render = this[RENDER] = createRenderer(this);\n        }\n        render(node, data);\n        return data;\n      }},\n\n      /**\n       * Invalidate this element's compiled template, so that it\n       * will be recompiled on the next render.\n       */\n      invalidate: {value: function() {\n        this[RENDER] = null;\n      }},\n\n      /**\n       * Returns the element's bound data.\n       */\n      data: property(\n        function readTemplateData(data) {\n          return data;\n        },\n        // eslint-disable-next-line no-unused-vars\n        function setTemplateData(data, previous) {\n          return this.render(data);\n        },\n        {}\n      )\n    }\n  )\n});\n\n// only listen for changes to the data attribute\nObject.defineProperty(Template, 'observedAttributes', {\n  get: function() {\n    return [DATA_ATTR];\n  }\n});\n\nmodule.exports = Template;\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./src/t-template.js\n ** module id = 1\n ** module chunks = 0\n **/","module.exports = function property(read, write, defaultValue) {\n  var symbol = '[[t-' + Date.now() + ']]';\n  return {\n    enumerable: false,\n\n    get: function() {\n      var value = (symbol in this)\n        ? this[symbol]\n        : this[symbol] = defaultValue;\n      return read\n        ? read.call(this, value)\n        : value;\n    },\n\n    set: function(value) {\n      var previous = this[symbol];\n      if (value !== previous) {\n        // eslint-disable-next-line no-return-assign\n        return this[symbol] = write.call(this, value, previous);\n      }\n      return undefined;\n    }\n  };\n};\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./src/property.js\n ** module id = 2\n ** module chunks = 0\n **/","/* eslint no-new-func: \"warn\" */\nvar arrow = require('./arrow');\nvar functor = require('./functor');\n\nvar evaluate = function(expression, data) {\n  var fn = evaluator(expression);\n  return fn.call(this, data);\n};\n\nvar evaluator = function(expression) {\n  if (typeof expression !== 'string') {\n    expression = String(expression);\n  }\n\n  if (!expression.trim()) {\n    return functor(undefined);\n  }\n\n  if (arrow.is(expression)) {\n    return arrow.parse(expression);\n  }\n\n  var symbol = 'd';\n  // '.' is just the identity function\n  if (expression.match(/^\\s*\\.\\s*$/)) {\n    return identity;\n  // '.foo' addresses the context directly\n  } else if (expression.match(/^\\s*\\.\\w/)) {\n    expression = symbol + expression;\n  }\n  return new Function(symbol, [\n    // 'console.info(\"', symbol, ' = \", ', symbol, ', \"', expression, '\"); ',\n    'try { ',\n    '  with (this) {',\n    '    with (', symbol, ') {',\n    '      return (', expression, ');',\n    '    } ',\n    '  } ',\n    '} catch (error) { }'\n  ].join('\\n'));\n};\n\nmodule.exports = {\n  evaluate: evaluate,\n  evaluator: evaluator\n};\n\nfunction identity(d) {\n  return d;\n}\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./src/evaluate.js\n ** module id = 3\n ** module chunks = 0\n **/","/* eslint no-new-func: \"warn\" */\nvar ARROW_PATTERN = /^\\s*\\(?(\\s*\\w+\\s*(,\\s*\\w+\\s*)*)?\\)?\\s*=>\\s*({([^}]+)}|(.+))$/;\n\nvar isArrow = function(expression) {\n  return String(expression).match(ARROW_PATTERN);\n};\n\nvar parseArrow = function parseArrow(expression) {\n  var match = expression.match(ARROW_PATTERN);\n  if (!match) throw new Error('invalid arrow expression: \"' + expression + '\"');\n  var args = match[1];\n  var body = (match[4] || match[5]).trim() || 'undefined';\n  return new Function(args, [\n    'with (this) {',\n    ' return ', body, '; ',\n    '}',\n  ].join(''));\n};\n\nmodule.exports = {\n  is: isArrow,\n  parse: parseArrow\n};\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./src/arrow.js\n ** module id = 4\n ** module chunks = 0\n **/","module.exports = function functor(x) {\n  return function f() {\n    return x;\n  };\n};\n\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./src/functor.js\n ** module id = 5\n ** module chunks = 0\n **/","var code = require('./evaluate');\nvar interpolate = require('./interpolate');\nvar compose = require('./compose');\nvar h = require('./h');\n\nvar morphdom = require('morphdom');\n\nvar T = require('./constants').T;\nvar T_ID = 't-id';\nvar attr = require('./attrs');\nvar dom = require('./dom');\nvar util = require('./util');\nvar ns = require('./ns');\nvar scope = require('./scope');\n\n// this is our symbol on which we stash registered event handlers, so that\n// we can remove any registered handlers before adding new ones.\nvar EVENTS = '[[t-events]]';\n\n// we stash unique event handler ids and handlers by id, each bound to the\n// renered template data\nvar eventHandlerId = 0;\nvar eventHandlersById = {};\n\n/**\n * Returns a function that generates an interpolated string for the\n * given text node (`node.nodeType === Node.TEXT_NODE`).\n *\n * @param {Node} node\n * @return {Function} function(data:Object):String\n */\nvar createTextRenderer = function(node) {\n  return compose.stringify(interpolate.compile(node.nodeValue));\n};\n\n/**\n * \"Pluck\" event handlers from an attribute map, removing them from\n * the map. If no event handlers are found, the return value is\n * `undefined`.\n *\n * @param {Object} attrMap\n * @return {Object}\n */\nvar pluckEventHandlers = function(attrMap) {\n  var handlers = undefined;\n  for (var name in attrMap) {\n    var value = attrMap[name];\n    if (name.indexOf('on') === 0 && typeof value === 'function') {\n      if (!handlers) {\n        handlers = {};\n      }\n      handlers[name.substr(2)] = value;\n      delete attrMap[name];\n    }\n  }\n  return handlers;\n};\n\n/**\n * This function returns a node rendering wrapper that registers event handlers\n * for the rendered node by assigning it a unique `t-id` attribute and stashing\n * a reference to the data-bound handlers in a corresponding hash. After the\n * tree is morphed, each element with a `t-id` attribute is then matched up\n * with its event handlers.\n *\n * @param {Function} render\n * @param {Object} handlers each key is an event type, and the value is a\n * callback function.\n * @return {Function} a function that returns the rendered node\n */\nvar registerEventHandlers = function(render, handlers) {\n  return function(data, index) {\n    var node = render.apply(this, arguments);\n    if (node) {\n      var tid = ++eventHandlerId;\n      node.setAttribute(T_ID, tid);\n      var context = this;\n      var callback = function(event) {\n        // XXX in theory, this could fail if one\n        // of the handlers gets removed (not\n        // sure how that would happen, though)\n        handlers[event.type].call(context, data, event);\n      };\n      var bound = {};\n      for (var type in handlers) {\n        bound[type] = callback;\n      }\n      eventHandlersById[tid] = bound;\n    }\n    return node;\n  };\n};\n\n/**\n * Returns a function that generates an interpolated DOM element tree\n * for the given element node\n * (`node.nodeType === Node.ELEMENT_NODE`).\n *\n * @param {Element} node\n * @return {Function} function(data:Object):Element\n */\nvar createElementRenderer = function(node) {\n  // this element will never be rendered if it has a truthy t-skip\n  // attribute\n  if (node.hasAttribute(T.SKIP)) {\n    return undefined;\n  }\n\n  var name = ns.getPrefixedName(node);\n  var attrMap = attr.getAttributeMap(node);\n  var handlers = pluckEventHandlers(attrMap);\n\n  var condition = node.hasAttribute(T.IF)\n    ? code.evaluator(node.getAttribute(T.IF))\n    : undefined;\n\n  if (node.hasAttribute(T.ELSE)) {\n    if (condition) {\n      throw new Error('element has both t-if and t-else attributes');\n    }\n    // TODO: ELSEIF should just collect all of the previous IF and\n    // ELSEIF nodes and negate them. Some checking should happen here to\n    // ensure that they're specified in the correct order.\n    var ifSibling = dom.getPreviousSibling(node, '[' + T.IF + ']');\n    if (!ifSibling) {\n      throw new Error('element with t-else has no matching t-if sibling');\n    }\n    condition = compose.not(code.evaluator(ifSibling.getAttribute(T.IF)));\n  }\n\n  var renderChildren;\n\n  // <span t-text=\"some.value\"></span>\n  if (node.hasAttribute(T.TEXT)) {\n    renderChildren = compose.stringify(\n      util.compileExpression(node.getAttribute(T.TEXT))\n    );\n  } else {\n    var childRenderers = [].map.call(node.childNodes, compile);\n    renderChildren = function(data) {\n      return childRenderers.map(function(renderChild, i) {\n        return (typeof renderChild === 'function')\n          ? renderChild.call(this, data)\n          : renderChild;\n      }, this);\n    };\n  }\n\n  var renderNode = function(data) {\n    if (condition && !condition.call(this, data)) {\n      return undefined;\n    }\n\n    var attrs = attr.interpolateAttributes.call(this, attrMap, data);\n    var children = renderChildren.call(this, data);\n    return h(name, attrs, children);\n  };\n\n  // \"attach\" (as a single property) the event handler maps\n  if (handlers) {\n    renderNode = registerEventHandlers(renderNode, handlers);\n  }\n\n  var eachExpression = node.getAttribute(T.EACH);\n  var forEachExpression = node.getAttribute(T.FOREACH);\n  var withExpression = node.getAttribute(T.WITH);\n\n  var symbol = node.getAttribute(T.AS);\n\n  if (eachExpression) {\n    renderNode = scope.renderEach(\n      code.evaluator(eachExpression),\n      renderNode,\n      symbol\n    );\n  } else if (forEachExpression) {\n    renderChildren = scope.renderEach(\n      code.evaluator(forEachExpression),\n      renderChildren,\n      symbol\n    );\n  } else if (withExpression) {\n    renderNode = scope.renderWith(\n      code.evaluator(withExpression),\n      renderNode,\n      symbol\n    );\n  } else if (symbol) {\n    renderNode = scope.symbolSetter(symbol, renderNode);\n  }\n\n  return renderNode;\n};\n\n/**\n * Returns a rendering function for a given source (\"template\") node\n * and optional variable context for expressions.\n *\n * The returned function has the signatures:\n *\n * function(data:*)\n * function(node:Node, data:*)\n *\n * Where `data` is expected to be an object and, in the second form,\n * `node` is a target node to which the diffed DOM should be applied.\n *\n * @param {Node}    src\n * @param {Object?} context\n * @return {Function}\n */\nvar createRenderer = function(src, context) {\n  if (typeof src === 'string') {\n    var selector = src;\n    src = document.querySelector(src);\n    if (!src) {\n      throw new Error('no element found with selector: \"' + selector + '\"');\n    }\n  }\n\n  var renderNode = compile(src);\n  return function(node, data, options) {\n    if (arguments.length < 2) {\n      data = node;\n    }\n    if ((!node && data) || node === data) {\n      node = src;\n    }\n    eventHandlerId = 0;\n    eventHandlersById = {};\n    var dest = renderNode.call(context, data);\n    var result = morphdom(src, dest, options);\n    updateEventHandlers(result);\n    return result;\n  };\n};\n\n/**\n * Update all of the event handlers in the given DOM tree. This looks for all\n * elements with the `t-id` attribute (including the root), removes any\n * existing handlers (stashed in the `[[t-events]]` symbol), then looks up the\n * registered handlers for the corresponding `t-id` value and adds those.\n *\n * @param {Element} root\n */\nvar updateEventHandlers = function(root) {\n  var elements = [].slice.call(root.querySelectorAll('[' + T_ID + ']'));\n  if (root.hasAttribute(T_ID)) {\n    elements.unshift(root);\n  }\n  elements.forEach(function(el) {\n    var events = el[EVENTS];\n    var type;\n    if (events) {\n      for (type in events) {\n        el.removeEventListener(type, events[type], true);\n        delete events[type];\n      }\n      delete el[EVENTS];\n    }\n    var tid = el.getAttribute(T_ID);\n    events = eventHandlersById[tid];\n    if (events) {\n      for (type in events) {\n        el.addEventListener(type, events[type], true);\n      }\n      el[EVENTS] = events;\n    }\n    el.removeAttribute(T_ID);\n  });\n};\n\n/**\n * Creates a renderer, renders once if data is provided, and returns\n * a bound rendering function for subsequent calling.\n *\n * @param {Node}    src\n * @param {Object?} context\n * @return {Function}\n */\nvar render = function(src, data, context) {\n  var renderData = createRenderer(src, context);\n  if (data) {\n    renderData(src, data);\n  }\n  return renderData;\n};\n\n/**\n * Returns a DOM element rendering function for the given \"template\"\n * or source node. This may be publicly exposed if it becomes useful,\n * e.g. for composition of referenced templates.\n *\n * @param {Node} node\n * @return {Function} the returned function takes data and returns an\n * unattached Node instance: function(data:Object):Node\n */\nvar compile = function(node) {\n  switch (node.nodeType) {\n    case 1: // Node.ELEMENT_NODE\n      return createElementRenderer(node);\n    case 3: // Node.TEXT_NODE\n      return createTextRenderer(node);\n\n    // TODO: support document fragments?\n    // this would need support in h()\n\n    default:\n      throw new Error('no renderer for node type: ' + node.nodeType);\n  }\n};\n\n\nmodule.exports.render = render;\nmodule.exports.createRenderer = createRenderer;\nmodule.exports.compile = compile;\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./src/render.js\n ** module id = 6\n ** module chunks = 0\n **/","var evaluate = require('./evaluate').evaluate;\nvar functor = require('./functor');\n\nvar pattern = /{{\\s*([^}]+)\\s*}}/g;\n\nvar isTemplate = function(str) {\n  return new RegExp(pattern).test(str);\n};\n\nvar compile = function(template) {\n  if (typeof template !== 'string') {\n    throw new Error('interpolate.compile() expected a string;' +\n                    'got ' + (typeof template));\n  }\n\n  if (!isTemplate(template)) {\n    return functor(template);\n  }\n\n  return function(data) {\n    var that = this;\n    return template.replace(pattern, function(_, part) {\n      return evaluate.call(that, part, data);\n    });\n  };\n};\n\nvar interpolate = function interpolate(str, data) {\n  return compile(str).call(this, data);\n};\n\nmodule.exports = interpolate;\n\nmodule.exports.isTemplate = isTemplate;\n\nmodule.exports.compile = compile;\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./src/interpolate.js\n ** module id = 7\n ** module chunks = 0\n **/","/**\n * functional composition functions take a function and return a\n * wrapped function that calls the passed one and applies some\n * additional logic.\n */\n\nvar defined = require('./util').defined;\n\n/**\n * @param {Function}  fn\n * @return {Function} a function that returns the inverse (`!`)\n *                    value of the `fn`, given the same arguments.\n */\nmodule.exports.not = function(fn) {\n  return function() {\n    return !fn.apply(this, arguments);\n  };\n};\n\n/**\n * @param {Function}  fn\n * @return {Function} a function that returns the stringified\n *                    value of the `fn`, given the same arguments.\n */\nmodule.exports.stringify = function(fn) {\n  return function() {\n    var value = fn.apply(this, arguments);\n    return defined(value) ? String(value) : '';\n  };\n};\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./src/compose.js\n ** module id = 8\n ** module chunks = 0\n **/","var code = require('./evaluate');\nvar interpolate = require('./interpolate');\n\nmodule.exports.defined = function(value) {\n  return value !== null && value !== undefined;\n};\n\nmodule.exports.compileExpression = function(expr) {\n  return interpolate.isTemplate(expr)\n    ? interpolate.compile(expr)\n    : code.evaluator(expr);\n};\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./src/util.js\n ** module id = 9\n ** module chunks = 0\n **/","var ns = require('./ns');\n\nmodule.exports = function(name, props, children) {\n  var node;\n  if (Array.isArray(name)) {\n    node = document.createDocumentFragment();\n  } else {\n    name = ns.qualify(name);\n    node = name.namespaceURI\n      ? document.createElementNS(name.namespaceURI, name.localName)\n      : document.createElement(name.localName);\n  }\n\n  if (Array.isArray(props) || typeof props === 'string') {\n    children = props;\n  } else if (typeof props === 'object') {\n    setProps(node, props);\n  }\n\n  var append = function(child) {\n    if (Array.isArray(child)) {\n      child.forEach(append);\n    } else if (typeof child === 'object') {\n      node.appendChild(child);\n    } else if (typeof child === 'string') {\n      node.appendChild(document.createTextNode(child));\n    }\n  };\n\n  if (typeof children === 'object' || typeof children === 'string') {\n    append(children);\n  }\n\n  return node;\n};\n\nvar setProps = function(el, props) {\n  for (var prop in props) {\n    if (!props.hasOwnProperty(prop)) {\n      continue;\n    }\n    var value = props[prop];\n    if (value === null || value === undefined || typeof value === 'function') {\n      // XXX: don't add null, undefined, or function values\n      continue;\n    } else if (typeof value === 'object') {\n      switch (prop) {\n        case 'class':\n          value = formatClassName(value);\n          break;\n\n        case 'style':\n          value = formatStyle(value);\n          break;\n\n        default:\n          console.warn('unrecognized object prop:', prop, value);\n          continue;\n      }\n    }\n\n    var name = ns.qualify(prop);\n    if (name.namespaceURI) {\n      el.setAttributeNS(name.namespaceURI, name.name, value);\n    } else {\n      el.setAttribute(name.localName, value);\n    }\n  }\n};\n\nvar formatStyle = function(obj) {\n  if (Array.isArray(obj)) {\n    return obj.join('; ');\n  }\n  return Object.keys(obj)\n    .map(function(key) {\n      return [\n        reformatCamelCase(key),\n        ': ',\n        obj[key],\n        ';'\n      ].join('');\n    })\n    .join(' ');\n};\n\nvar reformatCamelCase = function(str) {\n  return str.replace(/[A-Z]/g, function(char) {\n    return '-' + char.toLowerCase();\n  });\n};\n\nvar formatClassName = function(obj) {\n  if (Array.isArray(obj)) {\n    return obj.join(' ');\n  }\n  return Object.keys(obj).filter(function(key) {\n    return !!obj[key];\n  }).join(' ');\n};\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./src/h.js\n ** module id = 10\n ** module chunks = 0\n **/","var prefixToURI = {\n  svg: 'http://www.w3.org/2000/svg',\n  xlink: 'http://www.w3.org/TR/xlink/',\n  xmlns: 'http://www.w3.org/2000/xmlns/'\n};\n\nvar uriToPrefix = {};\nObject.keys(prefixToURI).forEach(function(prefix) {\n  uriToPrefix[prefixToURI[prefix]] = prefix;\n});\n\nvar qualify = function(qname) {\n  var prefix;\n  var localName = qname;\n  var colon = qname.indexOf(':');\n  if (colon > -1) {\n    prefix = qname.substr(0, colon);\n    localName = qname.substr(colon + 1);\n  }\n  return {\n    name: qname,\n    localName: localName,\n    prefix: prefix,\n    namespaceURI: prefixToURI[prefix]\n  };\n};\n\nvar getPrefixedName = function(node) {\n  var name = node.nodeName.toLowerCase();\n  var prefix = node.prefix;\n  if (!prefix && node.namespaceURI) {\n    prefix = uriToPrefix[node.namespaceURI];\n  }\n  return prefix\n    ? (prefix + ':' + name)\n    : name;\n};\n\nmodule.exports = {\n  getPrefixedName: getPrefixedName,\n  prefixToURI: prefixToURI,\n  uriToPrefix: uriToPrefix,\n  qualify: qualify\n};\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./src/ns.js\n ** module id = 11\n ** module chunks = 0\n **/","var prefix = 't-';\n\nvar T = {\n  PREFIX: prefix\n};\n\nT.AS = prefix + 'as';\nT.EACH = prefix + 'each';\nT.ELSE = prefix + 'else';\nT.FOREACH = prefix + 'foreach';\nT.IF = prefix + 'if';\nT.SKIP = prefix + 'skip';\nT.TEXT = prefix + 'text';\nT.WITH = prefix + 'with';\n\nmodule.exports.T = T;\n\nmodule.exports.CONTROL_ATTRS = [\n  'as',\n  'each',\n  'else',\n  'foreach',\n  'if',\n  'skip',\n  'text',\n  'with'\n];\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./src/constants.js\n ** module id = 12\n ** module chunks = 0\n **/","var constants = require('./constants');\nvar T_PREFIX = constants.T.PREFIX;\nvar CONTROL_ATTRS = constants.CONTROL_ATTRS;\n\nvar ns = require('./ns');\nvar util = require('./util');\nvar defined = util.defined;\n\nmodule.exports.getAttributeMap = function(node) {\n  var map = {};\n  var attrs = node.attributes;\n  for (var i = 0; i < attrs.length; i++) {\n    var attr = attrs[i];\n    var name = ns.qualify(attr.name);\n    var localName = name.localName;\n    var value = attr.value;\n    if (localName.indexOf(T_PREFIX) === 0) {\n      localName = localName.substr(T_PREFIX.length);\n      if (CONTROL_ATTRS.indexOf(localName) > -1) {\n        continue;\n      }\n      value = util.compileExpression(value);\n    }\n    var qname = name.prefix\n      ? name.prefix + ':' + localName\n      : localName;\n    map[qname] = value;\n  }\n  return map;\n};\n\nmodule.exports.interpolateAttributes = function(attrMap, data) {\n  var attrs = {};\n  for (var key in attrMap) {\n    if (!attrMap.hasOwnProperty(key)) {\n      continue;\n    }\n    var value = attrMap[key];\n    // only apply functions for attrs that aren't event handlers\n    if (typeof value === 'function' && key.indexOf('on') !== 0) {\n      value = value.call(this, data, key);\n    }\n    if (defined(value)) {\n      attrs[key] = value;\n    }\n  }\n  return attrs;\n};\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./src/attrs.js\n ** module id = 13\n ** module chunks = 0\n **/","module.exports.getPreviousSibling = function(node, selector) {\n  // eslint-disable-next-line no-cond-assign\n  while (node = node.previousSibling) {\n    if (!node) break;\n    // FIXME this needs a vendor prefix in IE 9+\n    // <http://caniuse.com/#search=matches>\n    if (node.nodeType === 1 && node.matches(selector)) {\n      return node;\n    }\n  }\n  throw new Error('no previous sibling found matching: ' + selector);\n};\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./src/dom.js\n ** module id = 14\n ** module chunks = 0\n **/","var renderEach = function(fn, render, symbol) {\n  return function(data) {\n    var values = fn.call(this, data);\n    return forEach.call(this, values, render, symbol);\n  };\n};\n\nvar renderWith = function(fn, render, symbol) {\n  render = symbolSetter(symbol, render);\n  return function(data) {\n    data = fn.call(this, data);\n    return render.call(this, data);\n  };\n};\n\nvar forEach = function(data, fn, symbol) {\n  var iterate = symbol\n    ? symbolSetter(symbol, fn)\n    : fn;\n\n  var result = [];\n  var INDEX = '$i';\n  var each = function(d, i) {\n    this[INDEX] = i;\n    result.push(iterate.call(this, d));\n    delete this[INDEX];\n  };\n\n  if (typeof data === 'object') {\n    if (Array.isArray(data)) {\n      data.forEach(each, this);\n    } else {\n      var i = 0;\n      for (var key in data) {\n        if (data.hasOwnProperty(key)) {\n          each.call(this, {key: key, value: data[key]}, i++);\n        }\n      }\n    }\n  } else if (typeof data === 'string') {\n    data.split('').forEach(each, this);\n  }\n\n  return result;\n};\n\nvar symbolSetter = function(symbol, fn) {\n  return function(data) {\n    var previous = set(this, symbol, data);\n    var result = fn.call(this, data);\n    set(this, symbol, previous);\n    return result;\n  };\n};\n\nvar set = function(context, symbol, value) {\n  var previous = context[symbol];\n  if (value === undefined) {\n    delete context[symbol];\n  } else {\n    context[symbol] = value;\n  }\n  return previous;\n};\n\nmodule.exports = {\n  renderWith: renderWith,\n  renderEach: renderEach,\n  symbolSetter: symbolSetter\n};\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./src/scope.js\n ** module id = 15\n ** module chunks = 0\n **/"],"sourceRoot":""}