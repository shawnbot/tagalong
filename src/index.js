var dom = require('incremental-dom');

var VOID_ELEMENTS = 'area base br col command embed hr img input keygen link meta param source track wbr'.split(' ');

module.exports = {
  compile: compile,
  /**
   * Bind data (with optional directives) to a node, and return a function that
   * can be used to rebind data to the same node.
   *
   * @example
   * var rebind = tagalong.bind('.template', data);
   * // later
   * rebind(otherData);
   *
   * @param {Node|String} node
   * @param {*}           data
   * @param {Object?}     directives
   */
  bind: function(node, data, directives) {
    var template = compile(node, directives);
    template(node, data);
    return function rebind(d) {
      return template(node, d || data);
    };
  }
};

/**
 * Compile a node (or CSS selector) and optional directives into a template
 * function. The source node is cloned once so that repeated bindings follow
 * the original template structure, rather than the one generated by previous
 * data bindings.
 *
 * @example
 * var template = tagalong.compile('.template');
 * template('.results', {});
 *
 * @param {Node|String} source
 * @param {Object?}     directives
 * @return {Function}   a template function that takes a target node and data
 */
function compile(source, directives) {
  if (typeof source === 'string') {
    source = document.querySelector(source);
  }
  if (!source) return noop;
  var template = binder(source.cloneNode(true), directives);
  return function(target, data) {
    if (typeof target === 'string') {
      target = document.querySelector(target);
    }
    if (!target) return null;
    // console.log('patching:', data, '-->', target);
    console.time('patch');
    var result = dom.patch(target, template(data));
    console.timeEnd('patch');
    return result;
  };
}

function binder(node, directives) {
  return function(data) {
    return function() {
      bindChildren(node, data, directives);
    };
  };
}

function bind(node, data, directives) {
  // console.log('bind:', data, '->', node, directives);
  if (Array.isArray(data)) {
    return bindArray(node, data, directives);
  } else if (data === false) {
    // only strictly false data causes an element to be skipped
    return;
  }

  var name = node.nodeName.toLowerCase();
  var attrs = interpolateAttributes(node, data, directives);
  var isVoid = VOID_ELEMENTS.indexOf(name) > -1;
  if (isVoid) {
    dom.elementVoid(name, '', attrs);
    return;
  }

  dom.elementOpen(name, '', attrs);
  switch (typeof data) {
    case 'string':
    case 'number':
      bindScalar(node, data, directives);
      break;

    case 'boolean':
    case 'object':
      // console.log('binding children:', data, '-->', node.childNodes);
      bindChildren(node, data, directives);
      break;
  }
  dom.elementClose(name);
}

function bindChildren(node, data, directives) {
  var values = interpolateData.call(node, data, directives);
  var key;
  for (var child = node.firstChild; child; child = child.nextSibling) {
    // console.log('child:', child);
    if (child.nodeType !== Node.ELEMENT_NODE) {
      if (child.nodeType === Node.TEXT_NODE) {
        dom.text(child.nodeValue);
      }
      continue;
    } else if (child.hasAttribute('data-if')) {
      key = child.getAttribute('data-if');
      var not = key.charAt(0) === '!'
        ? (key = key.substr(1), true)
        : false;
      var v = access.call(child, key, data);
      if (not ? v : !v) continue;
    }

    if (child.hasAttribute('data-each')) {
      key = child.getAttribute('data-each');
      var list = coalesce(data[key], directives[key]);
      if (Array.isArray(list)) {
        // console.log('bind array:', list, '->', child, directives[key]);
        bindArray(child, list, directives[key]);
      }
    } else if (child.hasAttribute('data-bind')) {
      key = child.getAttribute('data-bind');
      var v = access.call(child, key, data);
      var value = coalesce(v, directives[key]);
      bind(child, value, directives ? directives[key] : {});
    } else {
      bind(child, data, directives);
    }
  }
}

function bindArray(node, list, directives) {
  list.forEach(function(d) {
    bind(node, d, directives);
  });
}

function bindScalar(node, data, directives) {
  var target = node.querySelector('[data-bind="."]');
  if (target) {
    return bind(node, {'.': data}, directives);
  }

  if (typeof directives === 'function') {
    data = directives.call(node, data);
  }
  var text = stringify(data);
  dom.text(text);
}

function interpolateData(data, directives) {
  var result = extend({}, data);
  if (directives && typeof directives === 'object') {
    for (var key in directives) {
      if (key.charAt(0) === '@') continue;
      if (result.hasOwnProperty(key)) {
        if (typeof directives[key] === 'function') {
          result[key] = Array.isArray(result[key])
            ? result[key].map(directives[key], this)
            : access.call(this, directives[key], data, key);
        }
      } else {
        result[key] = directives[key];
      }
    }
  }
  return result;
}

function interpolateAttributes(node, data, directives) {
  if (!directives || typeof directives !== 'object') {
    return [];
  }
  var attrs = {};
  for (var attr in node.attributes) {
    attrs[attr.name] = attr.value;
  }
  for (var key in directives) {
    if (key.charAt(0) === '@') {
      attrs[key.substr(1)] = access.call(node, directives[key], data, key);
    }
  }
  return Object.keys(attrs)
    .reduce(function(list, attr) {
      return list.push(attr, attrs[attr]), list;
    }, []);
}

function access(key, data, i) {
  switch (typeof key) {
    case 'function':
      return key.call(this, data, i);
    case 'undefined':
      return null;
  }
  if (key === '.') {
    return data;
  } else if (key.indexOf('.') > 0) {
    var keys = key.split('.');
    for (var i = 0, len = keys.length; i < len; i++) {
      data = data[keys[i]];
      if (data === null || typeof data === 'undefined') {
        break;
      }
    }
    return data;
  }
  return data[key];
}

function style(styles, data) {
  if (!styles) return '';
  switch (typeof styles) {
    case 'object':
      return styles; // incremental-dom handles this internall
  }
  return stringify.call(this, styles, data);
}

function stringify(value) {
  if (value === null || typeof value === 'undefined') {
    return '';
  } else if (typeof value === 'object') {
    return JSON.stringify(value);
  } else if (typeof value === 'function') {
    return value.apply(this, [].slice.call(arguments, 1));
  }
  return String(value);
}

function noop() {
}

function extend(a, b) {
  for (var i = 1, len = arguments.length; i < len; i++) {
    if (arguments[i]) {
      var o = arguments[i];
      for (var key in o) a[key] = o[key];
    }
  }
  return a;
}

function coalesce() {
  for (var i = 0, len = arguments.length; i < len; i++) {
    var a = arguments[i];
    if (a !== null && typeof a !== 'undefined') return a;
  }
}
